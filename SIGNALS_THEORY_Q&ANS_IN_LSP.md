## Can you explain the concept of signals in programming? How are they used in Unix like operating systems?
```c
-> Signals are a form of inter-process communication (IPC) used in Unix-like operating systems to notify a process that a specific event has occurred. This operating systems use signals for:-
	Error handling (e.g., segmentation faults)
	Process control (e.g., kill, stop, continue)
	User interrupts (e.g., Ctrl+C to terminate a process)
	Timers and alarms
	Asynchronous I/O notifications
```

## What are software interrupts and hardware interrupts and mention potential issues when dealing with them?
```c
-> Interrupts are mechanisms that temporarily halt the normal execution flow of a program to respond to urgent events. They can come from hardware or software sources.
	
	1. Hardware Interrupts:-
  	   Generated by external hardware devices to signal the CPU that they need attention.
	Examples:-
		Keyboard press
		Mouse movement
		Disk I/O completion
		Network packet arrival

	Handled by:-
		Interrupt Service Routines (ISRs) in the kernel.

 	2. Software Interrupts
	   Generated by software or programs to trigger predefined behavior in the OS.
		Examples:-
			System calls (e.g., int 0x80 in Linux x86)
			Exception handling (e.g., divide by zero)
			Signals (SIGINT, SIGSEGV)

		Used For:-
			Accessing OS services
			Generating signals
			Simulating hardware behavior

```
## What is synchronous signal and asynchronous signal and how the process can be used for both?
```c
->  1. Synchronous Signal:-
		A synchronous signal is sent as a direct result of a process's own action. It happens while the process is running.
		Examples:-
			Divide by zero → SIGFPE
			Invalid memory access → SIGSEGV
			Illegal instruction → SIGILL
    2. Asynchronous Signal:-
		An asynchronous signal is sent from outside the process, and can happen at any time.
		Examples:-
			Pressing Ctrl+C in terminal → sends SIGINT
			Using kill command → sends SIGTERM, SIGKILL

     Now, How Can a Process Use Both?

	A process uses synchronous signals when it accidentally does something wrong.
	A process uses asynchronous signals when something outside (user/OS/other process) sends a signal.
	The process can handle both using signal handlers — small functions that run when the signal is received.

```
## Who is responsible for generating signals?
```c
-> Signals in Unix-like systems can be generated by different sources, depending on the type of event. 
	
	1. Operating System (Kernel):- Sends signals when a process causes errors/system events occur.
	Examples:
		SIGSEGV – invalid memory access
		SIGFPE – divide by zero
		SIGCHLD – child process exited

	2. User (via Keyboard):- User send signals using keyboard shortcuts in the terminal.
	Examples:
		Ctrl+C → SIGINT
		Ctrl+Z → SIGTSTP

	3. Other Processes:- A process can send a signal to another using system calls.
	Functions:
		kill(pid, signal)
		raise(signal)

	4. Timers/Alarms:- Signals are sent when timers expire.
	Example:
		alarm(5) → sends SIGALRM after 5 second

```
## What is signal handler?
```c
-> A signal handler is a special function in a program that gets called automatically when a specific signal is received.
	
	In Simple Explanation:- When a process receives a signal (like SIGINT or SIGSEGV), it normally Stops or Terminates. But if the process defines a signal handler, it can catch that signal and respond in a custom way instead of exiting.
	
	Why Use a Signal Handler?
		To clean up before exiting (close files, save data)
		To ignore certain signals
		To log errors before a crash
		To restart interrupted system calls

```
## Which system call is used to send a signal to the process?
```c
-> kill(pid, sig); — Sends sig to process pid.
	
	where, 
		pid: Process ID of the target process

		sig: Signal number to send (e.g., SIGINT, SIGTERM)

```
## Explain the default action associated with the SIGKILL signal?
```c
-> SIGKILL is a signal with number 9. It tells the operating system to immediately stop (terminate) a process. 
	
	What Happens Internally:-
	     When a process receives SIGKILL, the OS:-
			Stops the process immediately
			Releases its resources (memory, CPU time, etc.)
			Does not call any signal handler
			Does not allow saving files, closing files, or cleanup

```
## How does a process handle a signal while it is executing in kernel mode?
```c
-> When a process is executing in kernel mode (i.e., handling a system call or interrupt), signal handling is deferred until it returns to user mode. While the process is in kernel mode it( kernel ) just marks the signal as pending.
	Once the process finishes the kernel work and is about to return to user mode, the kernel checks for pending signals and delivers them at that point.

	So:
 	   Signal is received in kernel mode → it waits.
       	   Signal is delivered when back in user mode → handled then.

```
## Describe the behaviour of a process when it receives a SIGSEGV signal?
```c
-> When a process receives a SIGSEGV (Segmentation Fault) signal, It means the process tried to access invalid memory (e.g., NULL pointer/ unauthorized memory). By default, the operating system terminates the process immediately. A core dump may be generated (a file with memory info for debugging).

	 If a signal handler is set:-
		The process can catch the signal and try to handle the error gracefully.
		But this is rare and tricky for SIGSEGV.
		Let me know if you want a C code example of triggering or handling SIGSEGV.

```
## What is the role of the sigwait() function in signal handling?
```c
-> The sigwait() function plays a synchronous role in signal handling in Unix-like operating systems. 
	
	The main role of sigwait() is to:-		
		Wait for signals from a given set.
		Handle them synchronously (in a predictable and sequential way).
		Avoid the complexity and unpredictability of asynchronous signal handlers. 

```
## Explain the concept of signal correlation in a distributed environment?
```c
-> Signal correlation in a distributed environment defines that " Connecting related signals or events that come from different systems, processes, or sources to understand a single logical activity or incident ".

	 Why it is needed:-
		
		In distributed systems, many components run across different machines. Each one may send signals, logs, or alerts, which you need to group or match these signals to:
			Identify what actually happend.
			Detect patterns (e.g., failure in one system causes errors in another) & Debugging / monitoring effectively.
	
	 How Correlation Is Done:-
		
		Timestamps – Compare signal times.
		IDs or Tags – Match transaction IDs, session IDs, etc.
		Context Data – Match based on user, request type, or origin

```
## Explain how a process handles a signal while it is in the ready state?
```c
-> A process is in read state when it is:- 
		
		Not running, 
		But ready to be scheduled by the cpu
		Waiting in run queue.

	Signal Handling in Ready State (Step-by-Step):
		
		1. Signal is sent to the process (e.g., using kill() or from hardware/software).

		2. The signal is stored in the process’s pending signal set.

		3. Since the process is not running yet, it does NOT handle the signal immediately.

		4. When the process is scheduled and starts running, the kernel:-
			(i) Checks the pending signals.
			(ii) If a signal is pending and not blocked, it:
				Delivers the signal.
				Invokes the signal handler (if set) / performs the default action (e.g., terminate, ignore).
 
		5. After signal handling, the process continues or stops based on the action.

```
## What is the role of the sigqueue() function in signal handling?
```c
-> The sigqueue() function is used to send signals to a process — with additional data.
It is an advanced alternative to kill(), which can only send signals without any extra information.

	Purpose:-
		To send real-time signals (SIGRTMIN to SIGRTMAX)
		To attach user-defined data (like an integer or pointer) along with the signal & Useful in complex communication between processes or threads

```
## Describe the interaction between signals and IPC mechanisms in Unix-like systems?
```c
-> Signals and IPC are complementary tools in Unix & Signals notify or trigger actions; IPC transfers data & Using together carefully, both allow processes to coordinate, notify, and communicate efficiently.

	How Do Signals and IPC Work Together?
		1. Signal to Start Communication:
			A process sends a signal like SIGUSR1 to another process. The receiving process knows: “I got a signal! Let me read from the pipe or shared memory.”
		2. Signal to Tell Something Happened:
			Some IPC tools send signals when something changes.
				Example: A message queue can send a signal when a new message arrives.
		3. Use Signal + IPC for Sync:
			One process writes to shared memory. Then it sends a signal to another process to read the data.

```
## Explain how a process can determine the priority of a received signal?
```c
-> In Unix-like systems, signals have fixed priorities where lower-numbered signals have higher priority. If multiple signals are sent to a process while it's busy (blocked / not running), the kernel Stores them in the pending signal set & when the process is ready, it delivers the signal with the highest priority first. So, we use sigpending() to get the list of pending signals. which Loops through signal numbers in order to find the one with the lowest number ( the highest priority ).

```
## What is the role of the sigaltstack() function in signal handling?
```c
-> sigaltstack() is a function that allows a process to set up a special alternate stack to be used when handling signals, instead of the regular process stack.
	
	Why it is used?:-
		Some signals (like SIGSEGV, SIGBUS, SIGFPE) can be caused by stack overflow or memory errors. If the normal stack is corrupted, the signal handler might fail or crash. So, we use sigaltstack() to define a safe, separate stack just for signal handling.

	How it Works:-
		It create a new memory region to act as the alternate stack. And uses sigaltstack() to register it.And uses sigaction() with SA_ONSTACK flag to make specific signals use that alternate stack.

```
## Explain how a process can determine whether a signal was sent by the kernel or another process?
```c
-> In Unix-like operating systems, when a signal is delivered to a process, the process can find out who sent the signal using the sigaction() system call with the SA_SIGINFO flag, which the handler siginfo_t provides extended signal information about:-
								1. Who sent the signal
								2. Why the signal was sent

```
## Describe the interaction between signals and system calls in Unix-like systems?
```c
-> Signals are notifications sent to a process to inform it that event/action happened — like a user interrupt (Ctrl+C), timer expiration etc., And System calls are how a user-space process requests services from the kernel like read(), write(), sleep(), wait(), etc.

	How Signals & System Calls Interact:- When a signal is delivered while a system call is running, one of two things can happen:
							
				1. System Call Is Interrupted:
						The system call fails and returns -1, and errno is set to EINTR (Interrupted system call).
								This allows the program to handle the signal, then retry the system call if needed.
				2. System Call Is Automatically Restarted:
						For some system calls, the kernel can automatically restart/robust program after the signal is handled.
								This happens if the signal handler is installed with the SA_RESTART flag.

```
## How does a process handle a signal while it is waiting for a semaphore?
```c
-> The signal interrupts the sem_wait() system call.

	If no SA_RESTART flag: sem_wait() returns with error (EINTR) → process must handle or retry.

	If SA_RESTART is set: sem_wait() automatically resumes after the signal handler finishes.

```
## Describe the difference between a signal handler and a signal mask?
```c
| Feature                  | 		Signal Handler                       | 			Signal Mask                                      |
| -------------------------|-------------------------------------------------|------------------------------------------------------------------ |
|  Definition              | A function that runs when a signal is delivered | A setting that controls **which signals are blocked**             |
|  Purpose                 | To define **what action** to take for a signal  | To **temporarily block** certain signals from delivery            |
|  Set Using               | `signal()` or `sigaction()`                     | `sigprocmask()`, `pthread_sigmask()`, `sigset_t`                  |
|  Focus                   | Handles the **signal event itself**             | Controls the **timing** of signal delivery                        |
|  Action                  | Runs when signal is received (e.g., log, exit)  | Blocks signal until unmasked                                      |
|  Duration                | Runs **briefly during signal delivery**         | Can block signals **for long or short periods**                   |
|  Used For                | Handling signals like `SIGINT`, `SIGTERM`       | Avoiding interruption in **critical code sections**               |
|  Thread Safety           | Needs care in multithreading                    | Per-thread signal masks are supported via `pthread_sigmask()`     |
|  Receives Signals        | Yes, it processes the signal                    | No, it only controls whether the signal is delivered now or later |

```
## How does a process handle a signal while it is in the zombie state?
```c
-> A zombie process is a dead process that has finished execution, but its exit status is still stored in the system because its parent hasn’t read it yet using wait() or waitpid(). A zombie process cannot handle signals. 

	What Happens If a Signal Is Sent to a Zombie?
		Most signals are ignored or have no effect.
		Some signals (like SIGKILL, SIGTERM) are not delivered — because the process is already terminated.
	Note:	
	  Only one signal matters: SIGCHLD, which is sent to the parent when a child becomes a zombie.

```
## What are the advantages and disadvantages of using signals for inter process communication?
```c
Advantages:-
	
	1. Simple to Use
 		Just use kill(pid, signal) to send a signal.
		Easy for basic notifications (like telling a process when to stop or reload).

	2. Asynchronous Communication
		Signals can be delivered at any time, even when the target process is not actively listening.

	3. Lightweight
		No need to set up shared memory, pipes, or message queues.
		Minimal overhead.
	4. System-Wide Notification
		Works between unrelated processes as long as you know the target PID.

Disadvantages:-
	
	1. Limited Information
		Most signals carry no data, only a signal number.
		sigqueue() allows some data, but still very limited.

	2. Unreliable for Complex IPC
		If signals arrive too fast or get blocked, they may be missed or overwritten.
		No queuing for standard signals (except real-time signals).

	3. Hard to Debug and Maintain
		Signal handlers run asynchronously and can interrupt code at any point.
		Requires care to avoid race conditions and bugs.

```
## Explain how a process handles a signal while it is in a sleep state.
```c
-> A process is in the sleep state (or blocked state), when it is Waiting for something like input or timeout or a resource & not using the CPU during sleep state time. 
	Example:- wait(), sleep(), sem_wait() etc.

	What Happens if a Signal Arrives?

		When a signal is delivered to a sleeping process:

			1. The sleep is interrupted.

			2. If a signal handler is set, it is invoked immediately.

			3. After the handler runs, the process either:

					Gets an error (EINTR) if the sleep was interrupted, 
								or 
					The sleep call is automatically resumed, if SA_RESTART flag was set.

```
## How does a process handle a signal while it is in a critical section?
```c
->  The process can block signals using a signal mask while in the critical section. As this prevents signal handlers from interrupting the code. Once the critical section ends, the process unblocks signals, and any pending signals are then delivered.

|    Keyword      | 		Description                 |
| --------------- | --------------------------------------- |
| `sigprocmask()` | Apply the mask (block/unblock/replace)  |
| `SIG_BLOCK`     | Add signals to the blocked set          |
| `SIG_UNBLOCK`   | Remove signals from the blocked set     |
| `SIG_SETMASK`   | Replace the current mask with a new set |

```
## What are some of the challenges associated with signal handling in multi-threaded programs?
```c
-> Signal handling in multi-threaded applications is more complex than in single-threaded programs due to thread-specific behaviors and potential race conditions.

	Some key challenges are:-

		1. Unpredictable Signal Delivery:

				Signals sent to a process may be handled by any unblocked thread, making it hard to control.

		2. Thread-Specific Signal Masks:

				Each thread has its own mask; managing which thread blocks or handles a signal requires coordination.

		3. Asynchronous Interruptions

				Signals can interrupt any thread at any time, causing race conditions or data corruption.

		4. Unsafe Handler Functions

				Only a few functions are safe inside signal handlers; using unsafe ones can lead to crashes or deadlocks.

		5. Debugging Complexity

				Asynchronous and timing-related issues make signal-related bugs hard to trace and reproduce.

		6. Targeted Thread Signaling

				Using pthread_kill() sends signals to specific threads, but requires careful setup to ensure correct handling

```
## What is a race condition? Explain how it might occur in the context of signals?
```c
-> A race condition happens when two or more operations access shared data at the same time, and the final result depends on the timing or order of execution. If not managed properly, this leads to unexpected or incorrect behavior.

	In signal handling, a race condition can occur when:-

		A signal arrives and interrupts the main program.

		Both the main code and the signal handler try to access or modify the same data.

		Since the signal handler can interrupt at any time, the data can become inconsistent or corrupted.

	Precautions:- 
		
		By using sig_atomic_t or signal masks we can prevent race conditions in the context of signals.

```
## Discuss how a deadlock situation can be caused or resolved by signal handling?
```c
-> A deadlock is a situation where two or more processes or threads are stuck, each waiting for the other to release a resource, and none can proceed.

	Signal handling can cause deadlocks when:-

		1. A signal interrupts code that is holding a lock.

		2. The signal handler tries to acquire the same lock (or another dependent resource).

		3. Since the original code hasn’t finished and released the lock, both parts wait on each other forever.

	Why It Happens:-

		1. Signal handler is asynchronous and may interrupt in the middle of a lock-protected section.

		2. The handler then tries to re-acquire the same lock → deadlock.

	Resolving / Preventing Deadlocks with Signal Handling:-

		1. Avoid using locks in signal handlers

			Only use async-signal-safe functions.

			Do minimal work in the handler (e.g., set a flag).

		2. Use sig_atomic_t or flags

			Set a flag in the signal handler, and handle it in the main code.

		3. Block signals during critical sections

			Use sigprocmask() to block signals while holding locks.

```
## How can you use signals to force a process to dump core?
```c
-> We have make sure that the system allows to core dumps using ulimit -c unlimited

You can force a process to dump core by sending it a fatal signal like

|   Signal   |             Description                  |
| ---------- | ---------------------------------------- |
| `SIGSEGV`  | Segmentation fault                       |
| `SIGABRT`  | Abort (from `abort()` call)              |
| `SIGFPE`   | Floating point error (e.g., divide by 0) |
| `SIGILL`   | Illegal instruction                      |
| `SIGBUS`   | Bus error                                |

```
## What are the implications of using longjmp() and setjmp() in signal handlers?
```c
-> setjmp(env) saves the program's current execution state (stack, registers, etc) & longjmp(env, val) jumps back to the point saved by setjmp(), restoring that state. Where both are used for non-local jumps, often for error recovery — like an emergency exit from deep call stacks.

	 Implications / Risks:-

		1. Corrupted Program State:

			(i). Skipping normal flow using longjmp() may bypass cleanup code, such as:

				free() memory

				close() files

				Releasing locks or semaphores

			(ii). This can lead to memory leaks, deadlocks, or undefined behavior.

		2. Unsafe Stack / Registers:

			(i). If the signal interrupted code in a critical section, jumping out may leave:

				Partially updated data

				Broken logic

		3. Signal Safety:

			(i). longjmp() and setjmp() are not guaranteed to be async-signal-safe.

			(ii). In POSIX, siglongjmp() and sigsetjmp() are recommended because they:

				Save and restore the signal mask properly.

	Safe Alternative:-
		
		1. Use sigsetjmp() / siglongjmp() As these versions work like setjmp()/longjmp() but also save the signal mask:

```
## Difference between termination and suspending of a signal
```c
-> Termination signals ends a process forever & Termination is permanent and may produce a core dump.
   Suspension signals pauses a process temporarily & Suspension is safe and reversible.

|	 Aspect             | 				Termination                            |			 Suspension                               |
| ------------------------- | ---------------------------------------------------------------- | ---------------------------------------------------------------- |
| Definition                | Process is killed and removed from memory                        | Process is paused (stopped) but remains in memory                |
| Signal Types              | `SIGKILL`, `SIGTERM`, `SIGINT`, `SIGSEGV`, `SIGABRT`, etc.       | `SIGSTOP`, `SIGTSTP`, `SIGTTIN`, `SIGTTOU`                       |
| Reversibility             | Irreversible — once terminated, process cannot resume            | Reversible — use `SIGCONT` to resume                             |
| Delivery Result           | Causes process to "exit" immediately (possibly with core dump)   | Causes process to "stop execution" until resumed                 |
| Handler Capability        | Many signals (like `SIGTERM`) can be caught/handled              | Signals like `SIGSTOP` "cannot be caught, blocked, or ignored"   |
| Core Dump Possibility     | Yes — for fatal signals like `SIGSEGV`, `SIGABRT`                | No — suspended processes do "not" produce core dumps             |
| Process Table Entry       | Removed after termination (if reaped)                            | Remains in process table in `T (stopped)` state                  |
| Use Cases                 | To forcefully kill buggy or unneeded processes                   | To temporarily pause (e.g., for debugging or job control)        |
| Resuming Method           | Not possible                                                     | Use `SIGCONT` to resume execution                                |

```
## How CPU access the device register?
```c
->  Device registers are memory-mapped or I/O-mapped regions that control or monitor hardware devices (e.g., UART, timers, network cards). The CPU can access them to read/write configuration or data.
	
	 There are two main methods:-

		1. Memory-Mapped I/O (MMIO):-
			
				Device registers are mapped to specific physical memory addresses.

				CPU accesses them using normal load/store instructions (MOV, etc.) as if they were RAM.

			How it works:-

				The OS or firmware maps device register addresses (e.g., 0x40000000) using page tables.

				A pointer is used in C to access the register.


		2. Port-Mapped I/O (PMIO) (mainly x86 architecture):-

				Device registers are accessed using special instructions:

					IN, OUT (used only for I/O ports, not RAM)

				Registers are in a separate I/O address space, not in memory space.
		Note:-
			
		   The CPU accesses device registers either through memory-mapped I/O (treats them like memory) or port-mapped I/O (uses special instructions).
Modern systems (ARM, embedded, RISC-V) mostly use MMIO, while PMIO is common in older x86 PCs.

```
## what is IRQ line?
```c
-> IRQ stands for Interrupt Request. An IRQ line is a hardware signal line used by a device (like a keyboard, mouse, or network card) to request attention from the CPU.

	1. Each device is assigned a specific IRQ number or IRQ line.

	2. When the device generates an event, it pulls its IRQ line → this is sensed by the Interrupt Controller (like PIC/APIC/GIC).

	3. The interrupt controller sends an interrupt signal to the CPU.

	4. The CPU pauses current execution, runs the interrupt handler (ISR), then resumes.

	IRQ Number |	Device		 |
	---------------------------------|
	IRQ0	   | System timer        |
	IRQ1	   | Keyboard            |
	IRQ3	   | Serial port (COM2)  |
	IRQ4   	   | Serial port (COM1)  |
	IRQ14	   | Primary IDE channel |
	----------------------------------
Note:-
	In Modern systems often use interrupt remapping via APIC (Advanced Programmable Interrupt Controller) or MSI (Message Signaled Interrupts).

```
## How do you find out unique value for each IRQ line?
```c
->  From where do IRQ Values Come From?
	
	1. Hardware Level:-

		On x86 systems, IRQ lines are hard-wired to specific pins on the PIC (Programmable Interrupt Controller) or APIC.

		On ARM or embedded systems, they are routed through a GIC (Generic Interrupt Controller).

	2. Kernel Level:

		The OS assigns and tracks IRQ numbers for each device.

		These numbers are mapped and stored in kernel data structures.

    Ways to Find Unique IRQ Numbers in Linux:-

		1. By using -> cat /proc/interrupts

		2. By using -> lscpu -v / lshw -v / lspci -v  ~> (For PCI devices)

		3. By using -> dmesg | grep -i irq ~> This shows kernel logs including which devices were assigned which IRQs at boot time.

```
## when interrupt occurs?
```c
-> An interrupt occurs when the CPU is notified of an urgent event, either from hardware or software which causing it to temporarily pause execution & handle the event and then resume.
```
## what are exceptions when they occur?
```c
-> An exception is a type of interrupt generated by the CPU itself when it detects an error or special condition during instruction execution.

	Note:- Unlike external hardware interrupts, exceptions come from the CPU, not from devices.

    When Do Exceptions Occur?
	
	They occur immediately when the CPU detects something abnormal while executing an instruction.

```
# How does kernel informs to the parent that it(child) process is terminated?
```c
-> When a child process terminates Or stopped the kernel notifies the parent using SIGCHLD as a signal.

	What Happens Technically:-

		1. The child process exits (using exit() or _exit()).

		2. The kernel:-

			Marks the child as a zombie (temporarily)

			Sends SIGCHLD to the parent.

		3. The parent can:-

			Catch the SIGCHLD signal using a signal handler, or

			Ignores it, or

			Uses wait() / waitpid() to clean up the terminated child and prevents/removes the zombie entry from the process table.

```
## Which member of PCB contains the information about the signals?
```c
-> The information about signals for a process is stored in the " struct task_struct ", which is the Process Control Block (PCB) in the kernel.

	Where the task_struct contains members like:-

		1. sigpending → signals waiting to be delivered

		2. blocked → signals that are currently blocked (signal mask)

		3. sighand → pointer to the signal handlers

		4. signal → shared info for threads in the same process group

		5. exit_signal → signal sent to the parent when the process terminates 

```
## How can we replace SIG_DFL with SIG_ING.
```c
	|  Macro    |                Meaning                        |
	| --------- | --------------------------------------------- |
	| `SIG_DFL` | Perform the "default action" for the signal   |
	| `SIG_IGN` | *"Ignore" the signal completely               |

-> To replace default signal behavior (SIG_DFL) with ignoring signal behavior (SIG_IGN), we use " signal() " or " sigaction() ".

```
## How do you modify signal behaviour table/signal disposition
```c
-> You modify a process's signal behavior table using " signal() [ old Style ] " or " sigaction() [ POSIX ] ", by replacing default actions with custom handlers, ignoring, or resetting signals.

```
## why crash in program occurs?
```c
	A crash means the program unexpectedly stops or terminates abnormally due to a serious error/errors.
						( or )
	A program crashes when it performs an illegal or unsafe operation like invalid memory access, divide by zero, or resource mismanagement.

```
## How do you install signal handler in signal disposition table from user space?
```c
-> To install a signal handler from user space we use signal() or sigaction().

	When you call signal() or sigaction():-

		1. The kernel updates your process's signal disposition table (in the PCB).

		2. It sets the action for the specified signal to:

			SIG_DFL (default)

			SIG_IGN (ignore)

			(Or) your custom handler address

```
## How do you catch signal?
```c
-> To catch signal, define a handler function and register it using signal() or sigaction(). Then OS calls your handler, when the signal is received instead of applying the default action.

```
## What does header file contains?
```c
-> A header file contains declarations — such as function prototypes, constants, macros, structs, and global variable declarations, which is used to share interfaces between source files in a clean and organized way.

```
## How do you clear the content of sa_mask?
```c
-> We use " sigemptyset(&sa.sa_mask); " to clear the signal mask which means no signals will be blocked while your handler runs.

```
## Why signals are needed to be blocked?
```c
-> Signals are blocked to ensure safe, uninterrupted execution, especially in critical sections or multi-threaded environments. This helps to avoid crashes, race conditions & unpredictable behavior.

```
## Signal no 2's corresponding bit is set to 1? what do you meant by it?
```c
-> "Signal number 2's bit is set to 1" which means that "SIGINT" is either pending / blocked / being tracked in the kernel using a bitmask data structure, as the system uses this bitmask  to manage multiple signals efficiently by using one bit per signal.

```
## How can we see the blocking signal information in PC?
```c
-> You can view the blocked signals (i.e., the signal mask) of a process in user space using various tools / methods. They are as follows:-

	| Tool/Method             	 | Shows Blocked Signals? | Note                                              |
	| -------------------------------|------------------------|-------------------------------------------------- |
	| `/proc/[pid]/status` [ cmd ]   | Yes                    | Look for `SigBlk` [signal blocked]                |
	| `sigprocmask()` in code 	 | Yes                    | Programmatic access                               |
	| `strace`                	 | Yes, but limited       | Shows signal activity, not directly blocking info |

```
## How do I get access to some information present in kernel space?
```c
-> Eventhough their is no direct access to kernel memory , we can still retrieve/access kernel information through interfaces like /proc (procfs), /sys (sysfs), system calls, ioctl(), netlink sockets, or by writing a custom kernel module.

```
## During the execution of signal handler, other than default signal. Can you block additional signal?
```c
-> Yes, by using sigaction() and the sa_mask field, we can block additional signals during the execution of a signal handler

	Why Block Additional Signals?
	
		To prevent:-

			Interruptions by other signals during critical work in the handler.

			Nested signal handling which may lead to race conditions or inconsistent state.

			And giving fine-grained control over signal handling behavior

```
## Explain the scenario where signal is blocked?
```c
-> A signal is blocked when it is temporarily held back from being delivered and handled by a process or thread. This occurs when a program intentionally masks signals, or when signals are blocked during handler execution to ensure safe and predictable behavior

```
## From user space application can you access (Read/write) signal mask present in your PCB?
```c
-> Yes, from user space, we can read/write our own signal mask using system calls like sigprocmask() or pthread_sigmask(). Which safely to interact with the kernel's PCB.

```
## Where is the process information present?
```c
-> All process-related information is stored in the kernel memory specifically within a structure called " struct task_struct ", which is part of PCB and is maintained entirely by the kernel for each process.

```
## From userspace how do I access PCB information present in kernel space?
```c
-> We can’t access it directly, but user-level tools like " /proc/[pid]/status "," /proc/[pid]/stat "," ps " ptrace() " and system calls that provide controlled access ( like getpid, getppid etc.) to that information.

```
## Can you create a proc virtual file system entry as user?
```c
-> No, we can't create " /proc " entries as a user-space program. Only the kernel (via modules or built-in code) can create entries in " /proc ". But we can read and use " /proc " files to get system and process information.

```
## Without sending a signal can you invoke mysighand?
```c
-> Yes, you can call mysighand() without sending a signal, but it's just a normal function call, not real signal handling. 

	The correct way to set up and trigger real signal handling is:-
		
		signal(SIGINT, mysighand);  // Tells the kernel: "When I get SIGINT, run mysighand().  // Register the signal handler
		raise(SIGINT);              // Send the actual signal to the process

```	
## What is a Watchdog Timer?
```c
-> A watchdog timer is a timer used to detect and recover from software malfunctions.

	If your program hangs or stops responding, the watchdog timer will reset the system or take corrective action.

	As your program must "kick" or "reset" the watchdog regularly.


```
## Which of the following best describes a signal in system programming?
   ```c
A) A hardware interrupt generated by the CPU
✅B) A software interrupt delivered to a process
   C) A system call for inter-process communication
   D) A method for thread synchronization
```

## In a Unix-like operating system, what happens when a process receives a SIGSTOP signal?
   ```c
A) The process terminates immediately.
   B) The process is paused and can be resumed later.
   C) The process is terminated, but its resources are not released.
✅D) The process is suspended until a SIGCONT signal is received.
```

## Which of the following statements about signal handling in multithreaded programs is true?
  ```c
A) Each thread in a process has its own signal handler.
✅B) Signals can only be handled by the main thread of a process. 
  C) Signal handling behavior is undefined in multithreaded programs.
  D) Signals are always delivered to the thread that created them.
```

## In signal handling, what does the SA_NODEFER flag indicate when used with the sigaction() function?
```c
✅A) It specifies that the signal should not be blocked during its handler's execution.
  B) It specifies that the signal should be delivered only once.
  C) It specifies that the default action for the signal should be taken.
  D) It specifies that the signal should be ignored.
```

## The SIGPIPE signal is sent to a process when:-
   ```c
A) It encounters an illegal instruction
✅B) It writes to a pipe with no one to read from it
  C) It receives a termination request
  D) It receives a segmentation fault
```

## Which signal is typically sent to a parent process when a child process terminates?
  ```c
  A) SIGTERM
✅B) SIGCHLD
  C) SIGINT
  D) SIGSEGV
```

## Which function is used to establish a signal handler for a specific signal in C programming?
   ```c
   A) signal()
✅ B) sigaction()
   C) kill()
   D) raise()
```
